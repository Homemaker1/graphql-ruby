<p>To define your schema, define types and connect them with fields. Then, initialize your schema with root types (<code class="highlighter-rouge">query</code> and <code class="highlighter-rouge">mutation</code>). You can also customize your schema.</p>

<h2 id="defining-types">Defining Types</h2>

<h3 id="object-types">Object Types</h3>

<p>Use <code class="highlighter-rouge">GraphQL::ObjectType.define</code> to define types. Within the block, you can:</p>

<ul>
  <li>define properties: <code class="highlighter-rouge">name</code>, <code class="highlighter-rouge">description</code>, <code class="highlighter-rouge">interfaces</code></li>
  <li>define fields with the <code class="highlighter-rouge">field</code> helper</li>
  <li>access the <code class="highlighter-rouge">types</code> object, which exposes built-in scalar types (<code class="highlighter-rouge">types.Boolean</code>, <code class="highlighter-rouge">types.Int</code>, <code class="highlighter-rouge">types.Float</code>, <code class="highlighter-rouge">types.String</code>, <code class="highlighter-rouge">types.ID</code>)</li>
</ul>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">CityType</span> <span class="o">=</span> <span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="nb">name</span> <span class="s2">"City"</span>
  <span class="n">description</span> <span class="s2">"A large densely populated area"</span>
  <span class="n">interfaces</span> <span class="p">[</span><span class="no">LocationInterface</span><span class="p">,</span> <span class="no">NamedEntityInterface</span><span class="p">]</span>

  <span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">String</span><span class="p">,</span> <span class="s2">"The city's name"</span>

  <span class="c1"># `!` marks this field as non-null:</span>
  <span class="n">field</span> <span class="ss">:population</span><span class="p">,</span> <span class="o">!</span><span class="n">types</span><span class="o">.</span><span class="no">Int</span><span class="p">,</span> <span class="s2">"Number of people who live in this city"</span>

  <span class="c1"># This returns a list of `PersonType`s</span>
  <span class="n">field</span> <span class="ss">:mayors</span><span class="p">,</span> <span class="n">types</span><span class="p">[</span><span class="no">PersonType</span><span class="p">]</span>
  <span class="n">field</span> <span class="ss">:sisterCity</span><span class="p">,</span> <span class="no">CityType</span>
<span class="k">end</span>
</code></pre>
</div>

<h3 id="interface-types">Interface Types</h3>

<p>Interfaces provided a set of fields to <em>many</em> object types. When an object includes an interface, it gains the default resolve behavior from that interface.</p>

<p>Interfaces are defined with name, description and fields. For example:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">BeverageInterface</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">InterfaceType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="nb">name</span> <span class="s2">"Beverage"</span>
  <span class="n">field</span> <span class="ss">:caffeinated</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Boolean</span>
  <span class="n">field</span> <span class="ss">:size</span><span class="p">,</span> <span class="no">BeverageSizeEnum</span>
<span class="k">end</span>

<span class="c1"># Then, object types may include it:</span>
<span class="no">CoffeeType</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="n">interfaces</span><span class="p">([</span><span class="no">BeverageInterface</span><span class="p">])</span>
<span class="k">end</span>
</code></pre>
</div>

<p>In order for your schema to expose members of an interface, it must be able to determine the GraphQL type for a given Ruby object. You must define <code class="highlighter-rouge">resolve_type</code> in your schema:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">MySchema</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
 <span class="c1"># ...</span>
 <span class="n">resolve_type</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1"># for example, look up types by class name</span>
   <span class="n">type_name</span> <span class="o">=</span> <span class="n">object</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span>
   <span class="no">MySchema</span><span class="p">.</span><span class="nf">types</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span>
 <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<h3 id="union-types">Union Types</h3>

<p>Unions represent a set of object types which may occur in the same place.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">MediaSearchResultUnion</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">UnionType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="nb">name</span> <span class="s2">"MediaSearchResult"</span>
  <span class="n">description</span> <span class="s2">"An object which can be queried by date, location and filesize"</span>
  <span class="n">possible_types</span> <span class="p">[</span><span class="no">PhotoType</span><span class="p">,</span> <span class="no">VideoType</span><span class="p">,</span> <span class="no">AudioType</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>

<p>In order to expose a union, you must also define how the concrete type of each object can be determined. This is defined with <code class="highlighter-rouge">Schema</code>’s <code class="highlighter-rouge">resolve_type</code> function (see Interface docs).</p>

<h3 id="enum-types">Enum Types</h3>

<p>Enums define a set of values which maybe used as returns or inputs for the schema.</p>

<p>Each member of the enum has a <em>name</em> and a value. By default, the name is used as the value. But you can use <code class="highlighter-rouge">value:</code> to provide a custom value.</p>

<p>Each member may also have a description.</p>

<p>Values can be <em>deprecated</em> by providing a <code class="highlighter-rouge">deprecation_reason:</code>.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">ShirtSizeEnum</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">EnumType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="nb">name</span> <span class="s2">"ShirtSize"</span>
  <span class="n">description</span> <span class="s2">"T-shirt size"</span>
  <span class="n">value</span> <span class="s2">"LARGE"</span><span class="p">,</span> <span class="s2">"22 inches wide"</span>
  <span class="n">value</span> <span class="s2">"MEDIUM"</span><span class="p">,</span> <span class="s2">"20 inches wide"</span>
  <span class="n">value</span> <span class="s2">"SMALL"</span><span class="p">,</span> <span class="s2">"18 inches wide"</span>
  <span class="c1"># Custom value:</span>
  <span class="n">value</span> <span class="s2">"X-SMALL"</span><span class="p">,</span> <span class="s2">"16 inches wide"</span><span class="p">,</span> <span class="ss">value: </span><span class="mi">0</span>
  <span class="c1"># Deprecated value.</span>
  <span class="n">value</span> <span class="s2">"XX-SMALL"</span><span class="p">,</span> <span class="s2">"14 inches wide"</span><span class="p">,</span> <span class="ss">deprecation_reason: </span><span class="s2">"Nobody is this size anymore"</span>
<span class="k">end</span>
</code></pre>
</div>

<h3 id="input-object-types">Input Object Types</h3>

<p>Input objects are complex objects for fields. They may be passed for read operations (such as search queries) or for mutations (such as update payloads).</p>

<p>Input objects are composed of fields. Their fields may contain:</p>

<ul>
  <li>scalars (eg, boolean, string, int, float)</li>
  <li>enums</li>
  <li>lists</li>
  <li>input objects</li>
</ul>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># Place an order with this input, eg:</span>
<span class="c1"># {</span>
<span class="c1">#   model_id: "100",</span>
<span class="c1">#   selections: [</span>
<span class="c1">#     { quantity: 1, size: LARGE },</span>
<span class="c1">#     { quantity: 4, size: MEDIUM },</span>
<span class="c1">#     { quantity: 3, size: SMALL },</span>
<span class="c1">#   ] ,</span>
<span class="c1"># }</span>

<span class="no">ShirtOrderInput</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">InputObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="nb">name</span> <span class="s2">"ShirtOrder"</span>
  <span class="n">description</span> <span class="s2">"An order for some t-shirts"</span>
  <span class="n">input_field</span> <span class="ss">:model_id</span><span class="p">,</span> <span class="o">!</span><span class="n">types</span><span class="o">.</span><span class="no">ID</span>
  <span class="c1"># A list of other inputs:</span>
  <span class="n">input_field</span> <span class="ss">:selections</span><span class="p">,</span> <span class="n">types</span><span class="p">[</span><span class="no">ShirtOrderSelectionInput</span><span class="p">]</span>
<span class="k">end</span>

<span class="no">ShirtOrderSelectionInput</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">InputObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="nb">name</span> <span class="s2">"ShirtOrderSelection"</span>
  <span class="n">description</span> <span class="s2">"A quantity &amp; size to order for a given shirt"</span>
  <span class="n">input_field</span> <span class="ss">:quantity</span><span class="p">,</span> <span class="o">!</span><span class="n">types</span><span class="o">.</span><span class="no">Int</span>
  <span class="n">input_field</span> <span class="ss">:size</span><span class="p">,</span> <span class="o">!</span><span class="no">ShirtSizeEnum</span>
<span class="k">end</span>
</code></pre>
</div>

<h2 id="defining-fields">Defining Fields</h2>

<p>Usually, you’ll define fields while defining a type. The most common case defines a field name, type, and description. For example:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">String</span><span class="p">,</span> <span class="s2">"The name of this thing"</span>
</code></pre>
</div>

<h3 id="options">Options</h3>

<p>A field definition may include some options:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">String</span><span class="p">,</span> <span class="s2">"The name of this thing"</span><span class="p">,</span>
  <span class="c1"># Mark the field as deprecated:</span>
  <span class="ss">deprecation_reason: </span><span class="s2">"Nobody calls it by name anymore"</span><span class="p">,</span>
  <span class="c1"># Use a different getter method to resolve this field:</span>
  <span class="ss">property: :given_name</span><span class="p">,</span>
  <span class="c1"># Count this field as "10" when assessing the cost of running a query</span>
  <span class="ss">complexity: </span><span class="mi">10</span>
</code></pre>
</div>

<h3 id="block-definition">Block Definition</h3>

<p>For a more complex definition, you can also pass a definition block. Within the block, you can define <code class="highlighter-rouge">name</code>, <code class="highlighter-rouge">type</code>, <code class="highlighter-rouge">description</code>, <code class="highlighter-rouge">resolve</code>, and <code class="highlighter-rouge">argument</code>. For example:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:comments</span> <span class="k">do</span>
  <span class="n">type</span> <span class="o">!</span><span class="n">types</span><span class="p">[</span><span class="o">!</span><span class="no">CommentType</span><span class="p">]</span>

  <span class="n">description</span> <span class="s2">"Comments on this Post"</span>

  <span class="n">argument</span> <span class="ss">:moderated</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Boolean</span><span class="p">,</span> <span class="ss">default_value: </span><span class="kp">true</span>

  <span class="n">resolve</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">do</span>
     <span class="no">Comment</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span>
       <span class="ss">post_id: </span><span class="n">obj</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span>
       <span class="ss">moderated: </span><span class="n">args</span><span class="p">[</span><span class="s2">"moderated"</span><span class="p">]</span>
     <span class="p">)</span>
   <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This field accepts an optional Boolean argument <code class="highlighter-rouge">moderated</code>, which it uses to filter results in the <code class="highlighter-rouge">resolve</code> method.</p>

<h3 id="passing-an-existing-field">Passing an existing field</h3>

<p>You can provide a pre-made <code class="highlighter-rouge">GraphQL::Field</code> object to define a field:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">name_field</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Field</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="c1"># ...</span>

<span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="n">name_field</span>
</code></pre>
</div>

<p>This operation <strong>is destructive</strong>, so you need to use a new <code class="highlighter-rouge">GraphQL::Field</code> object for each field definition. (The <code class="highlighter-rouge">GraphQL::Field</code> receives a “name” from the <code class="highlighter-rouge">field</code> definition.)</p>

<h2 id="referencing-types">Referencing Types</h2>

<p>Some parts of schema definition take types as an input. There are two good ways to provide types:</p>

<ol>
  <li>
    <p><strong>By value</strong>. Pass a variable which holds the type.</p>

    <div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># constant</span>
<span class="n">field</span> <span class="ss">:team</span><span class="p">,</span> <span class="no">TeamType</span>
<span class="c1"># local variable</span>
<span class="n">field</span> <span class="ss">:stadium</span><span class="p">,</span> <span class="n">stadium_type</span>
</code></pre>
    </div>
  </li>
  <li>
    <p><strong>By proc</strong>, which will be lazy-evaluated to look up a type.</p>

    <div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:team</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="no">TeamType</span> <span class="p">}</span>
<span class="n">field</span> <span class="ss">:stadium</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="no">LookupTypeForModel</span><span class="p">.</span><span class="nf">lookup</span><span class="p">(</span><span class="no">Stadium</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
    </div>
  </li>
</ol>

<h2 id="defining-the-schema">Defining the Schema</h2>

<p>Your schema can be initialized with some options:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">MySchema</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">query</span> <span class="no">QueryType</span><span class="p">,</span>       <span class="c1"># root type for read-only queries</span>
  <span class="n">mutation</span> <span class="no">MutationType</span><span class="p">,</span> <span class="c1"># root type for mutations</span>
  <span class="n">max_depth</span> <span class="mi">7</span><span class="p">,</span>           <span class="c1"># if present, the max depth for incoming queries</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Additionally, you can define error handling and custom middleware as described below.</p>

<h2 id="handling-errors">Handling Errors</h2>

<p>You can rescue errors by defining handlers with <code class="highlighter-rouge">Schema#rescue_from</code>. The handler receives the error instance and it should return a string. The returned string will be added to the <code class="highlighter-rouge">"errors"</code> key.</p>

<p>For example, you can set up a handler:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># The error instance is yielded to the block:</span>
<span class="no">MySchema</span><span class="p">.</span><span class="nf">rescue_from</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">RecordInvalid</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">error</span><span class="o">|</span> <span class="s2">"Some data could not be saved"</span> <span class="p">}</span>
</code></pre>
</div>

<p>Then, when a query is executed, that error is rescued and its message is added to the response:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query_string</span><span class="p">)</span>
<span class="c1"># {</span>
<span class="c1">#   "data" =&gt; {</span>
<span class="c1">#     # other fields may resolve successfully</span>
<span class="c1">#   },</span>
<span class="c1">#   "errors" =&gt; [</span>
<span class="c1">#     {</span>
<span class="c1">#       "message" =&gt; "Some data could not be saved",</span>
<span class="c1">#       "locations" =&gt; [{"line" =&gt; 5, "column" =&gt; 10}]</span>
<span class="c1">#      }</span>
<span class="c1">#   ]</span>
<span class="c1"># }</span>
</code></pre>
</div>

<p>When explicitly raising the exception, you can raise a <code class="highlighter-rouge">GraphQL::ExecutionError</code> with a message to add to the response without specifying an error handler.</p>

<h2 id="middleware">Middleware</h2>

<p>You can use <em>middleware</em> to affect the evaluation of fields in your schema. They function like <code class="highlighter-rouge">before_action</code>s and <code class="highlighter-rouge">after_action</code>s in Rails controllers.</p>

<p>A middleware is any object that responds to <code class="highlighter-rouge">#call(*args, next_middleware)</code>. Inside that method, it should either:</p>

<ul>
  <li>send <code class="highlighter-rouge">call</code> to the next middleware to continue the evaluation; or</li>
  <li>return a value to end the evaluation early.</li>
</ul>

<p>Middlewares’ <code class="highlighter-rouge">#call</code> is invoked with several arguments:</p>

<ul>
  <li><code class="highlighter-rouge">parent_type</code> is the type whose field is being accessed</li>
  <li><code class="highlighter-rouge">parent_object</code> is the object being exposed by that type</li>
  <li><code class="highlighter-rouge">field_definition</code> is the definition for the field being accessed</li>
  <li><code class="highlighter-rouge">field_args</code> is the hash of arguments passed to the field</li>
  <li><code class="highlighter-rouge">query_context</code> is the context object passed throughout the query</li>
  <li><code class="highlighter-rouge">next_middleware</code> represents the execution chain. Call <code class="highlighter-rouge">#call</code> to continue evalution.</li>
</ul>

<p>Add a middleware to a schema by adding to the <code class="highlighter-rouge">#middleware</code> array.</p>

<h3 id="example-authorization">Example: Authorization</h3>

<p>This middleware only continues evaluation if the <code class="highlighter-rouge">current_user</code> is permitted to read the target object:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AuthorizationMiddleware</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">parent_type</span><span class="p">,</span> <span class="n">parent_object</span><span class="p">,</span> <span class="n">field_definition</span><span class="p">,</span> <span class="n">field_args</span><span class="p">,</span> <span class="n">query_context</span><span class="p">,</span> <span class="n">next_middleware</span><span class="p">)</span>
    <span class="n">current_user</span> <span class="o">=</span> <span class="n">query_context</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">]</span> <span class="c1"># passed in when creating the query</span>
    <span class="k">if</span> <span class="n">current_user</span> <span class="o">&amp;&amp;</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">can_read?</span><span class="p">(</span><span class="n">parent_object</span><span class="p">)</span>
      <span class="c1"># This user is authorized, so continue execution</span>
      <span class="n">next_middleware</span><span class="p">.</span><span class="nf">call</span>
    <span class="k">else</span>
      <span class="c1"># Silently halt execution</span>
      <span class="kp">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Then, add the middleware to your schema:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">MySchema</span><span class="p">.</span><span class="nf">middleware</span> <span class="o">&lt;&lt;</span> <span class="no">AuthorizationMiddleware</span><span class="p">.</span><span class="nf">new</span>
</code></pre>
</div>

<p>Now, all field access will be wrapped by that authorization routine.</p>

<h2 id="query-analyzers">Query Analyzers</h2>

<p>Query analyzers are like middleware for the validation phase. They’re called at each node of the query’s internal representation (see <code class="highlighter-rouge">GraphQL::InternalRepresentation::Node</code>). If they return a <code class="highlighter-rouge">GraphQL::AnalysisError</code>, the query won’t be run and the error will be added to the response’s <code class="highlighter-rouge">errors</code> key.</p>

<p>The minimal API is <code class="highlighter-rouge">.call(memo, visit_type, internal_representation_node)</code>. For example:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">ast_node_logger</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">memo</span><span class="p">,</span> <span class="n">visit_type</span><span class="p">,</span> <span class="n">internal_representation_node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">visit_type</span> <span class="o">==</span> <span class="ss">:enter</span>
    <span class="nb">puts</span> <span class="s2">"Visiting </span><span class="si">#{</span><span class="n">internal_representation_node</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">!"</span>
  <span class="k">end</span>
<span class="p">}</span>
<span class="no">MySchema</span><span class="p">.</span><span class="nf">query_analyzers</span> <span class="o">&lt;&lt;</span> <span class="n">ast_node_logger</span>
</code></pre>
</div>

<p>Whatever <code class="highlighter-rouge">.call(...)</code> returns will be passed as <code class="highlighter-rouge">memo</code> for the next visit.</p>

<p>The analyzer can implement a few other methods. If they’re present, they’ll be called:</p>

<ul>
  <li><code class="highlighter-rouge">.initial_value(query)</code> will be called to generate an initial value for <code class="highlighter-rouge">memo</code></li>
  <li><code class="highlighter-rouge">.final_value(memo)</code> will be called <em>after</em> visiting the the query</li>
</ul>

<p>If the last value of <code class="highlighter-rouge">memo</code> (or the return of <code class="highlighter-rouge">.final_value</code>) is a <code class="highlighter-rouge">GraphQL::AnalysisError</code>, the query won’t be executed and the error will be added to the <code class="highlighter-rouge">errors</code> key of the response.</p>

<p><code class="highlighter-rouge">graphql-ruby</code> includes a few query analyzers:
- <code class="highlighter-rouge">GraphQL::Analysis::QueryDepth</code> and <code class="highlighter-rouge">GraphQL::Analysis::QueryComplexity</code> for inspecting query depth and complexity
- <code class="highlighter-rouge">GraphQL::Analysis::MaxQueryDepth</code> and <code class="highlighter-rouge">GraphQL::Analysis::MaxQueryComplexity</code> are used internally to implement <code class="highlighter-rouge">max_depth:</code> and <code class="highlighter-rouge">max_complexity:</code> options</p>

<h2 id="extending-type-and-field-definitions">Extending type and field definitions</h2>

<p>Types, fields, and arguments have a <code class="highlighter-rouge">metadata</code> hash which accepts values during definition.</p>

<p>First, make a custom definition:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">accepts_definitions</span> <span class="ss">resolves_to_class_names: </span><span class="no">GraphQL</span><span class="o">::</span><span class="no">Define</span><span class="p">.</span><span class="nf">assign_metadata_key</span><span class="p">(</span><span class="ss">:resolves_to_class_names</span><span class="p">)</span>
<span class="c1"># or:</span>
<span class="c1"># GraphQL::Field.accepts_definitions(...)</span>
<span class="c1"># GraphQL::Argument.accepts_definitions(...)</span>
</code></pre>
</div>

<p>Then, use the custom definition:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">Post</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="n">resolves_to_class_names</span> <span class="p">[</span><span class="s2">"Post"</span><span class="p">,</span> <span class="s2">"StaffUpdate"</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Access <code class="highlighter-rouge">type.metadata</code> later:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">MySchema</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="c1"># Use the type's declared `resolves_to_class_names`</span>
  <span class="c1"># to figure out if `obj` is a member of that type</span>
  <span class="n">resolve_type</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">class_name</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span>
    <span class="no">MySchema</span><span class="p">.</span><span class="nf">types</span><span class="p">.</span><span class="nf">values</span><span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">type</span><span class="o">|</span> <span class="n">type</span><span class="p">.</span><span class="nf">metadata</span><span class="p">[</span><span class="ss">:resolves_to_class_names</span><span class="p">].</span><span class="nf">include?</span><span class="p">(</span><span class="n">class_name</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
