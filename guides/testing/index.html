<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>GraphQL Ruby</title>
    <link rel="stylesheet" href="/stylesheet.css">
    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="Nanoc 4.1.4">
  </head>
  <body class="hack">
    <div class="container">
      <div style="display: flex; justify-content: center;">
<strong style="white-space: pre; line-height: 1.1em; display: inline-block; font-size: 8px;">
    ▄██████▄     ▄████████    ▄████████    ▄███████▄    ▄█    █▄    ████████▄    ▄█
   ███    ███   ███    ███   ███    ███   ███    ███   ███    ███   ███    ███  ███
   ███    █▀    ███    ███   ███    ███   ███    ███   ███    ███   ███    ███  ███
  ▄███         ▄███▄▄▄▄██▀   ███    ███   ███    ███  ▄███▄▄▄▄███▄▄ ███    ███  ███
 ▀▀███ ████▄  ▀▀███▀▀▀▀▀   ▀███████████ ▀█████████▀  ▀▀███▀▀▀▀███▀  ███    ███  ███
   ███    ███ ▀███████████   ███    ███   ███          ███    ███   ███    ███  ███
   ███    ███   ███    ███   ███    ███   ███          ███    ███   ███  ▀ ███  ███▌    ▄
   ████████▀    ███    ███   ███    █▀   ▄████▀        ███    █▀     ▀██████▀▄█ █████▄▄██
                ███    ███                                                      ▀
</strong>
      </div>
      <p style="text-align: center;">A GraphQL server implementation for Ruby</p>

      <div class="grid -between">
        <div class="cell -3of12">
          <h3><a href="/">Readme</a></h3>
          <h3>Guides</h3>
          <ul>
            <li><a href="/guides/introduction/">Introduction</a></li>
            <li><a href="/guides/defining_your_schema/">Defining a Schema</a></li>
            <li><a href="/guides/executing_queries/">Executing Queries</a></li>
            <li><a href="/guides/code_reuse/">Code Reuse</a></li>
            <li><a href="/guides/security/">Security</a></li>
            <li><a href="/guides/testing/">Testing</a></li>
          </ul>
          <h3><a href="http://www.rubydoc.info/github/rmosolgo/graphql-ruby">API Docs</a></h3>
          <h3><a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a></h3>
        </div>
        <div class="cell -9of12">
          <h1>Testing a GraphQL Schema</h1>

<p>There are a few ways to test the behavior of your GraphQL schema:</p>

<ul>
<li><em>Don&#39;t</em> test the schema, test other objects instead</li>
<li>Test schema elements (types, fields) in isolation</li>
<li>Execute GraphQL queries and test the result</li>
</ul>

<h2>Don&#39;t test the schema</h2>

<p>The easiest way to test behavior of a GraphQL schema is to extract behavior into separate objects and test those objects in isolation. For Rails, you don&#39;t test your models by running controller tests, right? Similarly, you can test &quot;lower-level&quot; parts of the system on their own without running end-to-end tests.</p>

<p>For example, consider a field which calculates its own value:</p>
<pre class="highlight ruby"><code><span class="no">PostType</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="n">field</span> <span class="ss">:isTrending</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Boolean</span> <span class="k">do</span>
    <span class="n">resolve</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">recent_comments</span> <span class="o">=</span> <span class="n">comments</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &lt; ?"</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
      <span class="n">recent_comments</span><span class="p">.</span><span class="nf">count</span> <span class="o">&gt;</span> <span class="mi">100</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>You can refactor this by creating a new class and applying it to your GraphQL schema:</p>
<pre class="highlight ruby"><code><span class="c1"># app/models/post/trending.rb</span>
<span class="k">class</span> <span class="nc">Post</span>
  <span class="k">class</span> <span class="nc">Trending</span>
    <span class="nc">TRENDING_COMMENTS_COUNT</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
      <span class="vi">@post</span> <span class="o">=</span> <span class="n">post</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">value</span>
      <span class="n">recent_comments</span> <span class="o">=</span> <span class="vi">@post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &lt; ?"</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
      <span class="n">recent_comments</span><span class="p">.</span><span class="nf">count</span> <span class="o">&gt;</span> <span class="no">TRENDING_COMMENTS_COUNT</span>       
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># ....</span>

<span class="no">PostType</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="n">field</span> <span class="ss">:isTrending</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Boolean</span> <span class="k">do</span>
    <span class="n">resolve</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1"># Use the Post::Trending class to calculate the value</span>
      <span class="no">Post</span><span class="o">::</span><span class="no">Trending</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">obj</span><span class="p">).</span><span class="nf">value</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This is an improvement because your behavior is not coupled to your GraphQL schema. Besides that, it&#39;s easier to test: you can simply unit test the calculation class. For example:</p>
<pre class="highlight ruby"><code><span class="c1"># app/models/post/trending_spec.rb</span>
<span class="n">describe</span> <span class="no">Post</span><span class="o">::</span><span class="no">Trending</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:post</span><span class="p">)</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:post</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:trending</span><span class="p">)</span> <span class="p">{</span> <span class="no">Post</span><span class="o">::</span><span class="no">Trending</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">post</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">"#value"</span> <span class="k">do</span>
    <span class="n">context</span> <span class="s2">"when there are no recent comments"</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s2">"is false"</span> <span class="k">do</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">trending</span><span class="p">.</span><span class="nf">value</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s2">"when there are more than 100 recent comments"</span> <span class="k">do</span>
      <span class="n">before</span> <span class="k">do</span>
        <span class="mi">101</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:comment</span><span class="p">,</span> <span class="ss">post: </span><span class="n">post</span><span class="p">)</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="s2">"is true"</span> <span class="k">do</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">trending</span><span class="p">.</span><span class="nf">value</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<h2>Testing schema elements in isolation</h2>

<p>You can access type and field objects from your schema to make sure they&#39;re defined correctly and behave the way you expect them to.</p>

<h4>Types</h4>

<p>Access a type by name from the schema with <code>GraphQL::Schema#types</code>:</p>
<pre class="highlight ruby"><code><span class="n">post</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">types</span><span class="p">[</span><span class="s2">"Post"</span><span class="p">]</span> <span class="c1"># =&gt; PostType</span>
<span class="n">post</span><span class="p">.</span><span class="nf">fields</span>                   <span class="c1"># =&gt; {"id" =&gt; &lt;GraphQL::Field&gt;, ... }</span>
<span class="n">post</span><span class="p">.</span><span class="nf">fields</span><span class="p">.</span><span class="nf">keys</span>              <span class="c1"># =&gt; ["id", "title", "body", "author", "comments"]</span>
</code></pre>

<p>The returned value is an instance of the type class you used to <code>.define</code> it (eg, <code>GraphQL::ObjectType</code>, <code>GraphQL::EnumType</code>, <code>GraphQL::InputObjectType</code>).</p>

<h4>Fields</h4>

<p>You can get a type&#39;s fields from the <code>GraphQL::ObjectType#fields</code> hash. For example:</p>
<pre class="highlight ruby"><code><span class="n">post_type</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">types</span><span class="p">[</span><span class="s2">"Post"</span><span class="p">]</span>
<span class="n">title_field</span> <span class="o">=</span> <span class="n">post_type</span><span class="p">.</span><span class="nf">fields</span><span class="p">[</span><span class="s2">"title"</span><span class="p">]</span> <span class="c1">#=&gt; &lt;GraphQL::Field&gt;</span>
<span class="n">title_field</span><span class="p">.</span><span class="nf">name</span> <span class="c1">#=&gt; "title"</span>
</code></pre>

<p>You can test a resolve function by calling <code>GraphQL::Field#resolve</code>:</p>
<pre class="highlight ruby"><code><span class="c1"># Because this field doesn't use context or variables, simply pass `nil`</span>
<span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">title: </span><span class="s2">"Welcome to my blog"</span><span class="p">)</span>
<span class="n">name_field</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="n">post</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">)</span> <span class="c1">#=&gt; "Welcome to my blog"</span>
</code></pre>

<p>Calling <code>resolve</code> in this way does <em>not</em> apply any coercion. (That&#39;s only applied during query execution.)</p>

<h4>Other elements</h4>

<p>Similarly, you can access:</p>

<ul>
<li><code>GraphQL::Field#arguments</code>, which are <code>String</code> =&gt; <code>GraphQL::Argument</code> pairs</li>
<li><code>GraphQL::Field#type</code>, the field&#39;s return type</li>
<li><code>GraphQL::InputObjectType#arguments</code>, which are <code>String</code> =&gt; <code>GraphQL::Argument</code> pairs</li>
<li><code>GraphQL::EnumType#values</code>, which are <code>String</code> =&gt; <code>GraphQL::EnumType::EnumValue</code> pairs</li>
<li><code>GraphQL::InterfaceType#possible_types</code> and <code>GraphQL::UnionType#possible_types</code>, which are lists of types.</li>
</ul>

<p><code>GraphQL::BaseType#unwrap</code> may also be helpful. It returns the &quot;inner-most&quot; type. For example:</p>
<pre class="highlight ruby"><code><span class="n">required_list_of_strings</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">NonNullType</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">of_type: </span><span class="no">GraphQL</span><span class="o">::</span><span class="no">ListType</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="ss">of_type: </span><span class="no">GraphQL</span><span class="o">::</span><span class="no">STRING_TYPE</span>
  <span class="p">)</span>
<span class="p">)</span>

<span class="n">required_list_of_strings</span><span class="p">.</span><span class="nf">unwrap</span> <span class="c1">#=&gt; GraphQL::STRING_TYPE</span>
</code></pre>

<h2>Executing GraphQL queries</h2>

<p>Sometimes, you really need an end-to-end test. Although it requires a lot of overhead, it&#39;s nice to have a &quot;sanity check&quot; on the system as a whole.</p>

<p>You can execute queries on your schema in a test. For example, you can set it up like this:</p>
<pre class="highlight ruby"><code><span class="n">describe</span> <span class="no">MySchema</span> <span class="k">do</span>
  <span class="c1"># You can override `context` or `variables` in</span>
  <span class="c1"># more specific scopes</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:context</span><span class="p">)</span> <span class="p">{</span> <span class="p">{}</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:variables</span><span class="p">)</span> <span class="p">{</span> <span class="p">{}</span> <span class="p">}</span>
  <span class="c1"># Call `result` to execute the query</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span>
      <span class="n">query_string</span><span class="p">,</span>
      <span class="ss">context: </span><span class="n">context</span><span class="p">,</span>
      <span class="ss">variables: </span><span class="n">variables</span>
    <span class="p">)</span>
    <span class="c1"># Print any errors</span>
    <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="s2">"errors"</span><span class="p">]</span>
      <span class="n">pp</span> <span class="n">res</span>
    <span class="k">end</span>
    <span class="n">res</span>
  <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">"a specific query"</span> <span class="k">do</span>
    <span class="c1"># provide a query string for `result`</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:query_string</span><span class="p">)</span> <span class="p">{</span><span class="sx">%|{ viewer { name } }|</span><span class="p">}</span>

    <span class="n">context</span> <span class="s2">"when there's no current user"</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s2">"is nil"</span> <span class="k">do</span>
        <span class="c1"># calling `result` executes the query</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">"data"</span><span class="p">][</span><span class="s2">"viewer"</span><span class="p">]).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s2">"when there's a current user"</span> <span class="k">do</span>
      <span class="c1"># override `context`</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:context</span><span class="p">)</span> <span class="p">{{</span>
        <span class="ss">current_user: </span><span class="no">User</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"ABC"</span><span class="p">)</span>
      <span class="p">}}</span>

      <span class="n">it</span> <span class="s2">"shows the user's name"</span> <span class="k">do</span>
        <span class="n">user_name</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"data"</span><span class="p">][</span><span class="s2">"viewer"</span><span class="p">][</span><span class="s2">"name"</span><span class="p">]</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">user_name</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="s2">"ABC"</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

        </div>
      </div>
    </div>
  </body>
</html>
